no-index clustering
===================
	- nodes can join/leave at any time
	- nodes have maximum store size set (-m 8 (always in GB) for example)
	- Each node informs their other known nodes of following:
		- (1 sec) Space in store that is available
			- Acts as a PING, if nothing from a node is received
			  in 10 seconds the node is considered dead.
		- (10 seconds) Exchange known nodes (to complete list of nodes)
	- On PUT, node selects 2 suitable nodes to hold copies of key.
		- How do we prevent 2 nodes from inserting same keys
		  at the same time? This is an issue.
		- Done after we notify issuer the PUT is successfull
		  (we don't want to block insertation from a caller pov).
	- On GET, if key is not known ask other nodes for it.
		- This can become slow if amount of nodes grows?
	- When a node writes its store to disk, check if certain keys
	  have copies available. Otherwise we must issue copies if possible.

	If a key has copies, flag NODE_DATA_HASCOPIES is set (0x10). This
	indicates that the region holds a struct key_copy after the data
	of the key.

	If key is a copy, flag NODE_DATA_ISCOPY is set (0x20) this indicates
	to the node that it must NOT replicate this copy further. When this
	flag is set the region will hold an u_int32_t extra after the offset
	of the data to indicate the original owner of this key.

	How do we store what nodes have copies of a key? Add it to region?
		struct key_copy {
			u_int32_t	nodes[3];
		};

		if (node->flags & NODE_DATA_HASCOPIES) {
			nodes = ... node->region ...
		}

cyon_cluster_join(pass, node);
cyon_cluster_inform(message, content);
cyon_cluster_recv();
