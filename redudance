Clustering mechanics
====================

All node servers a single threaded processes with event based I/O.
(provides serialization in its operations).

If node B has neighbour nodes C and D, C and D do not know they are neighbour
for node B specifically. (Until at least B sends a REPL to them).

Existing cluster:	B, C, D

New node A joins existing node B:
	# cyon-server -s node_a -j node-b.coders.se

	- A connects and auths to B
	- B sends A a list of all its known nodes (C, D)
	- A selects 2 neighbours from the received nodes and connects to them
	- A marks B as a neighbour node as well

Imaging scenario:
	|-----------------|
	A -----> B -----> C <---- D
	|        |----------------|
	|-------------------------|

	UPDATEIDX:
		- Has a timestamp and key attached to it
		- Nodes will not replace existing keys with newer timestamp

	PUT happens on B node (key=113):
		- B adds the content
			- B emits UPDATEIDX for key, with its own timestamp
			- B has 2 neighbours: A, C
				- B emits REPL to A
				- B emits REPL to C
		- A receives content, adds it to the store
			- A emits UPDATEIDX for key, with timestamp from B
		- C receives content, adds it to the store
			- C emits UPDATEIDX for key, with timestamp from B

	GET happens on C node (key=113):
		- C looks in its storeindex, finds key=113 and sees it
		  holds the contents itself
		- C returns content to caller

	GET happens on D node (key=113) (D does not have content):
		- D looks in its storeindex, finds key=113 and sees the
		  content is available at A, B, C

	If node C dies, D lost its neighbour:
		- D notices that C is gone and from existing nodes
		  elects a new neighbour to replace it

PUT on node B, but node B is full:
	- What to do?
