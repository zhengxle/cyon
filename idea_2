Keyspace:
	[ 000 ] -> keyspace root
	[ 001 ] -> keyspace root
	[ 002 ] -> keyspace root
	[ ... ] -> keyspace root
	[ 255 ] -> keyspace root

keyspace_root {
	u_int8_t		bottom;
	u_int8_t		top;
	u_int32_t		hosts[2];
}

Each keyspace MUST have 2 hosts so before keyspace is divided the host
is added to the keyspace with the keyspace with < 2 hosts.

A single node has a single keyspace, ranging from 0-255.
When a new node joins, this keyspace is replicated to create redudancy.

When a third node joins, the initial keyspace (0-255) has redudancy, the
nodes will then decide what entry in the keyspace to assign to the new node.

For example, if keyspace 0x4D (M) has a lot of entries. The nodes can decide
together to assign this to the newly joined node. They will then both
send their entries for keyspace 0x4D to the new node. Once the replication
is complete the 2 nodes decide who of the 2 will forget 0x4D. This node
removes all entries from 0x4D and marks 0x4D as a keyspace available on
the other 2 nodes. (In effect providing proper replication for all available
keyspaces).

Another example:
	At single node keyspace is 256.
	New node joins, keyspace is = 256/2 (2 keyspaces of each 128).
	Another node joins, first 128 keyspace is dvided into 2.
	Another node joins, second keyspace is divided into 2
	Now we have 4 keyspaces of each 64

On startup nodes that own a keyspace must ask the other node[s?] that own
it for the newest data (see async_replication?).

How do we provide keyspaces after the root? For example, a keyspace
starting at the fifth entry. (think 's' in joris_test).

PUT happening on a node for a key it doesnt have the keyspace for will
result in that node to temporary save the data, forward it to the right
node and when it receives notification that the data has been saved, remove it.
