Keyspace:
	[ 000 ] -> keyspace root
	[ 001 ] -> keyspace root
	[ 002 ] -> keyspace root
	[ ... ] -> keyspace root
	[ 255 ] -> keyspace root

keyspace_root {
	u_int8_t		bottom;
	u_int8_t		top;
	u_int32_t		hosts[2];
}

Each keyspace MUST have 2 hosts so before keyspace is divided the host
is added to the keyspace with the keyspace with < 2 hosts.

A single node has a single keyspace, ranging from 0-255.
When a new node joins, this keyspace is replicated to create redudancy.

When a third node joins, the initial keyspace (0-255) has redudancy, the
nodes will then decide what entry in the keyspace to assign to the new node.

For example, if keyspace 0x4D (M) has a lot of entries. The nodes can decide
together to assign this to the newly joined node. They will then both
send their entries for keyspace 0x4D to the new node. Once the replication
is complete the 2 nodes decide who of the 2 will forget 0x4D. This node
removes all entries from 0x4D and marks 0x4D as a keyspace available on
the other 2 nodes. (In effect providing proper replication for all available
keyspaces).

Another example:
	- First node started, keyspace is 256
	- Second node joins cluster, keyspace is still 256 (2 hosts)
	- Third node joins cluster, keyspace is divided into 2 parts:
		- Lower 128 and higher 128
		- New node receives lower 128, together with first node.
		- Second node receives higher 128, together with first node.
		- First node still owns full keyspace range at this point.
	- Fourth node joins cluster, keyspace is reassigned for equality
		- Fourth now receives lower 128 together with third node
		- First node reshuffles to only own higher 128 as the
		  lower 128 now has 2 hosts assigned to it.
	- End result:
		- 2 nodes per 128 key space.
	- Repeat until we run out of dividable keyspace?

On startup nodes that own a keyspace must ask the other node[s?] that own
it for the newest data (see async_replication?).

How do we provide keyspaces after the root? For example, a keyspace
starting at the fifth entry. (think 's' in joris_test).

PUT happening on a node for a key it doesnt have the keyspace for will
result in that node to temporary save the data, forward it to the right
node and when it receives notification that the data has been saved, remove it.
